package cell

import (
	"context"
	"testing"
	"time"

	"github.com/astrosteveo/fleetforge/api/v1"
)

func TestNewCell(t *testing.T) {
	spec := CellSpec{
		ID:         "test-cell-1",
		Boundaries: createTestBounds(),
		Capacity: CellCapacity{
			MaxPlayers:  50,
			CPULimit:    "500m",
			MemoryLimit: "1Gi",
		},
	}

	cell, err := NewCell(spec)
	if err != nil {
		t.Fatalf("Failed to create cell: %v", err)
	}

	if cell.state.ID != spec.ID {
		t.Errorf("Expected cell ID %s, got %s", spec.ID, cell.state.ID)
	}

	if cell.state.Capacity.MaxPlayers != spec.Capacity.MaxPlayers {
		t.Errorf("Expected capacity %d, got %d", spec.Capacity.MaxPlayers, cell.state.Capacity.MaxPlayers)
	}

	if cell.state.Phase != "Initializing" {
		t.Errorf("Expected phase 'Initializing', got %s", cell.state.Phase)
	}
}

func TestNewCell_EmptyID(t *testing.T) {
	yMin := float64(0)
	yMax := float64(1000)
	spec := CellSpec{
<<<<<<< HEAD
		ID:         "",
		Boundaries: createTestBounds(),
=======
		ID: "",
		Boundaries: v1.WorldBounds{
			XMin: 0, XMax: 1000,
<<<<<<< HEAD
			YMin: &yMinVal, YMax: &yMaxVal,
=======
			YMin: &yMin, YMax: &yMax,
>>>>>>> main
		},
>>>>>>> origin/main
	}

	_, err := NewCell(spec)
	if err == nil {
		t.Error("Expected error for empty cell ID")
	}
}

func TestCell_StartStop(t *testing.T) {
	yMin := float64(0)
	yMax := float64(1000)
	spec := CellSpec{
<<<<<<< HEAD
		ID:         "test-cell-2",
		Boundaries: createTestBounds(),
		Capacity:   CellCapacity{MaxPlayers: 10},
=======
		ID: "test-cell-2",
		Boundaries: v1.WorldBounds{
			XMin: 0, XMax: 1000,
<<<<<<< HEAD
			YMin: &yMinVal, YMax: &yMaxVal,
=======
			YMin: &yMin, YMax: &yMax,
>>>>>>> main
		},
		Capacity: CellCapacity{MaxPlayers: 10},
>>>>>>> origin/main
	}

	cell, err := NewCell(spec)
	if err != nil {
		t.Fatalf("Failed to create cell: %v", err)
	}

	ctx := context.Background()
	err = cell.Start(ctx)
	if err != nil {
		t.Fatalf("Failed to start cell: %v", err)
	}

	// Wait for cell to become ready
	time.Sleep(time.Millisecond * 150)

	state := cell.GetState()
	if state.Phase != "Running" {
		t.Errorf("Expected phase 'Running', got %s", state.Phase)
	}

	if !state.Ready {
		t.Error("Expected cell to be ready")
	}

	err = cell.Stop()
	if err != nil {
		t.Fatalf("Failed to stop cell: %v", err)
	}

	state = cell.GetState()
	if state.Phase != "Stopped" {
		t.Errorf("Expected phase 'Stopped', got %s", state.Phase)
	}
}

func TestCell_AddPlayer(t *testing.T) {
	yMin := float64(0)
	yMax := float64(1000)
	spec := CellSpec{
<<<<<<< HEAD
		ID:         "test-cell-3",
		Boundaries: createTestBounds(),
		Capacity:   CellCapacity{MaxPlayers: 10},
=======
		ID: "test-cell-3",
		Boundaries: v1.WorldBounds{
			XMin: 0, XMax: 1000,
<<<<<<< HEAD
			YMin: &yMinVal, YMax: &yMaxVal,
=======
			YMin: &yMin, YMax: &yMax,
>>>>>>> main
		},
		Capacity: CellCapacity{MaxPlayers: 10},
>>>>>>> origin/main
	}

	cell, err := NewCell(spec)
	if err != nil {
		t.Fatalf("Failed to create cell: %v", err)
	}

	ctx := context.Background()
	err = cell.Start(ctx)
	if err != nil {
		t.Fatalf("Failed to start cell: %v", err)
	}

	// Wait for cell to become ready
	time.Sleep(time.Millisecond * 150)

	player := &PlayerState{
		ID:        "player-1",
		Position:  WorldPosition{X: 500, Y: 500},
		Connected: true,
	}

	err = cell.AddPlayer(player)
	if err != nil {
		t.Fatalf("Failed to add player: %v", err)
	}

	state := cell.GetState()
	if state.PlayerCount != 1 {
		t.Errorf("Expected player count 1, got %d", state.PlayerCount)
	}

	if _, exists := state.Players[player.ID]; !exists {
		t.Error("Player not found in cell state")
	}

	cell.Stop()
}

func TestCell_AddPlayer_OutOfBounds(t *testing.T) {
	yMin := float64(0)
	yMax := float64(1000)
	spec := CellSpec{
<<<<<<< HEAD
		ID:         "test-cell-4",
		Boundaries: createTestBounds(),
		Capacity:   CellCapacity{MaxPlayers: 10},
=======
		ID: "test-cell-4",
		Boundaries: v1.WorldBounds{
			XMin: 0, XMax: 1000,
<<<<<<< HEAD
			YMin: &yMinVal, YMax: &yMaxVal,
=======
			YMin: &yMin, YMax: &yMax,
>>>>>>> main
		},
		Capacity: CellCapacity{MaxPlayers: 10},
>>>>>>> origin/main
	}

	cell, err := NewCell(spec)
	if err != nil {
		t.Fatalf("Failed to create cell: %v", err)
	}

	ctx := context.Background()
	err = cell.Start(ctx)
	if err != nil {
		t.Fatalf("Failed to start cell: %v", err)
	}

	// Wait for cell to become ready
	time.Sleep(time.Millisecond * 150)

	player := &PlayerState{
		ID:        "player-1",
		Position:  WorldPosition{X: 1500, Y: 500}, // Outside boundaries
		Connected: true,
	}

	err = cell.AddPlayer(player)
	if err == nil {
		t.Error("Expected error for player outside boundaries")
	}

	cell.Stop()
}

func TestCell_AddPlayer_AtCapacity(t *testing.T) {
	yMin := float64(0)
	yMax := float64(1000)
	spec := CellSpec{
<<<<<<< HEAD
		ID:         "test-cell-5",
		Boundaries: createTestBounds(),
		Capacity:   CellCapacity{MaxPlayers: 1},
=======
		ID: "test-cell-5",
		Boundaries: v1.WorldBounds{
			XMin: 0, XMax: 1000,
<<<<<<< HEAD
			YMin: &yMinVal, YMax: &yMaxVal,
=======
			YMin: &yMin, YMax: &yMax,
>>>>>>> main
		},
		Capacity: CellCapacity{MaxPlayers: 1},
>>>>>>> origin/main
	}

	cell, err := NewCell(spec)
	if err != nil {
		t.Fatalf("Failed to create cell: %v", err)
	}

	ctx := context.Background()
	err = cell.Start(ctx)
	if err != nil {
		t.Fatalf("Failed to start cell: %v", err)
	}

	// Wait for cell to become ready
	time.Sleep(time.Millisecond * 150)

	// Add first player
	player1 := &PlayerState{
		ID:        "player-1",
		Position:  WorldPosition{X: 500, Y: 500},
		Connected: true,
	}

	err = cell.AddPlayer(player1)
	if err != nil {
		t.Fatalf("Failed to add first player: %v", err)
	}

	// Try to add second player (should fail)
	player2 := &PlayerState{
		ID:        "player-2",
		Position:  WorldPosition{X: 600, Y: 600},
		Connected: true,
	}

	err = cell.AddPlayer(player2)
	if err == nil {
		t.Error("Expected error when adding player beyond capacity")
	}

	cell.Stop()
}

func TestCell_RemovePlayer(t *testing.T) {
	yMin := float64(0)
	yMax := float64(1000)
	spec := CellSpec{
<<<<<<< HEAD
		ID:         "test-cell-6",
		Boundaries: createTestBounds(),
		Capacity:   CellCapacity{MaxPlayers: 10},
=======
		ID: "test-cell-6",
		Boundaries: v1.WorldBounds{
			XMin: 0, XMax: 1000,
<<<<<<< HEAD
			YMin: &yMinVal, YMax: &yMaxVal,
=======
			YMin: &yMin, YMax: &yMax,
>>>>>>> main
		},
		Capacity: CellCapacity{MaxPlayers: 10},
>>>>>>> origin/main
	}

	cell, err := NewCell(spec)
	if err != nil {
		t.Fatalf("Failed to create cell: %v", err)
	}

	ctx := context.Background()
	err = cell.Start(ctx)
	if err != nil {
		t.Fatalf("Failed to start cell: %v", err)
	}

	// Wait for cell to become ready
	time.Sleep(time.Millisecond * 150)

	player := &PlayerState{
		ID:        "player-1",
		Position:  WorldPosition{X: 500, Y: 500},
		Connected: true,
	}

	err = cell.AddPlayer(player)
	if err != nil {
		t.Fatalf("Failed to add player: %v", err)
	}

	err = cell.RemovePlayer(player.ID)
	if err != nil {
		t.Fatalf("Failed to remove player: %v", err)
	}

	state := cell.GetState()
	if state.PlayerCount != 0 {
		t.Errorf("Expected player count 0, got %d", state.PlayerCount)
	}

	if _, exists := state.Players[player.ID]; exists {
		t.Error("Player still exists in cell state after removal")
	}

	cell.Stop()
}

func TestCell_UpdatePlayerPosition(t *testing.T) {
	yMin := float64(0)
	yMax := float64(1000)
	spec := CellSpec{
<<<<<<< HEAD
		ID:         "test-cell-7",
		Boundaries: createTestBounds(),
		Capacity:   CellCapacity{MaxPlayers: 10},
=======
		ID: "test-cell-7",
		Boundaries: v1.WorldBounds{
			XMin: 0, XMax: 1000,
<<<<<<< HEAD
			YMin: &yMinVal, YMax: &yMaxVal,
=======
			YMin: &yMin, YMax: &yMax,
>>>>>>> main
		},
		Capacity: CellCapacity{MaxPlayers: 10},
>>>>>>> origin/main
	}

	cell, err := NewCell(spec)
	if err != nil {
		t.Fatalf("Failed to create cell: %v", err)
	}

	ctx := context.Background()
	err = cell.Start(ctx)
	if err != nil {
		t.Fatalf("Failed to start cell: %v", err)
	}

	// Wait for cell to become ready
	time.Sleep(time.Millisecond * 150)

	player := &PlayerState{
		ID:        "player-1",
		Position:  WorldPosition{X: 500, Y: 500},
		Connected: true,
	}

	err = cell.AddPlayer(player)
	if err != nil {
		t.Fatalf("Failed to add player: %v", err)
	}

	newPosition := WorldPosition{X: 600, Y: 600}
	err = cell.UpdatePlayerPosition(player.ID, newPosition)
	if err != nil {
		t.Fatalf("Failed to update player position: %v", err)
	}

	state := cell.GetState()
	updatedPlayer := state.Players[player.ID]
	if updatedPlayer.Position.X != newPosition.X || updatedPlayer.Position.Y != newPosition.Y {
		t.Errorf("Expected position %v, got %v", newPosition, updatedPlayer.Position)
	}

	cell.Stop()
}

func TestCell_GetPlayersInArea(t *testing.T) {
	yMin := float64(0)
	yMax := float64(1000)
	spec := CellSpec{
<<<<<<< HEAD
		ID:         "test-cell-8",
		Boundaries: createTestBounds(),
		Capacity:   CellCapacity{MaxPlayers: 10},
=======
		ID: "test-cell-8",
		Boundaries: v1.WorldBounds{
			XMin: 0, XMax: 1000,
<<<<<<< HEAD
			YMin: &yMinVal, YMax: &yMaxVal,
=======
			YMin: &yMin, YMax: &yMax,
>>>>>>> main
		},
		Capacity: CellCapacity{MaxPlayers: 10},
>>>>>>> origin/main
	}

	cell, err := NewCell(spec)
	if err != nil {
		t.Fatalf("Failed to create cell: %v", err)
	}

	ctx := context.Background()
	err = cell.Start(ctx)
	if err != nil {
		t.Fatalf("Failed to start cell: %v", err)
	}

	// Wait for cell to become ready
	time.Sleep(time.Millisecond * 150)

	// Add players at different positions
	players := []*PlayerState{
		{ID: "player-1", Position: WorldPosition{X: 100, Y: 100}, Connected: true},
		{ID: "player-2", Position: WorldPosition{X: 150, Y: 150}, Connected: true},
		{ID: "player-3", Position: WorldPosition{X: 500, Y: 500}, Connected: true},
	}

	for _, player := range players {
		err = cell.AddPlayer(player)
		if err != nil {
			t.Fatalf("Failed to add player %s: %v", player.ID, err)
		}
	}

	// Get players in area around (100, 100) with radius 100
	center := WorldPosition{X: 100, Y: 100}
	playersInArea := cell.GetPlayersInArea(center, 100)

	// Should include player-1 and player-2, but not player-3
	if len(playersInArea) != 2 {
		t.Errorf("Expected 2 players in area, got %d", len(playersInArea))
	}

	cell.Stop()
}

func TestCell_Health(t *testing.T) {
	yMin := float64(0)
	yMax := float64(1000)
	spec := CellSpec{
<<<<<<< HEAD
		ID:         "test-cell-9",
		Boundaries: createTestBounds(),
		Capacity:   CellCapacity{MaxPlayers: 10},
=======
		ID: "test-cell-9",
		Boundaries: v1.WorldBounds{
			XMin: 0, XMax: 1000,
<<<<<<< HEAD
			YMin: &yMinVal, YMax: &yMaxVal,
=======
			YMin: &yMin, YMax: &yMax,
>>>>>>> main
		},
		Capacity: CellCapacity{MaxPlayers: 10},
>>>>>>> origin/main
	}

	cell, err := NewCell(spec)
	if err != nil {
		t.Fatalf("Failed to create cell: %v", err)
	}

	ctx := context.Background()
	err = cell.Start(ctx)
	if err != nil {
		t.Fatalf("Failed to start cell: %v", err)
	}

	// Wait for cell to become ready
	time.Sleep(time.Millisecond * 150)

	health := cell.GetHealth()
	if !health.Healthy {
		t.Error("Expected cell to be healthy")
	}

	if health.PlayerCount != 0 {
		t.Errorf("Expected player count 0, got %d", health.PlayerCount)
	}

	if health.Uptime <= 0 {
		t.Error("Expected positive uptime")
	}

	cell.Stop()
}

func TestCell_Metrics(t *testing.T) {
	yMin := float64(0)
	yMax := float64(1000)
	spec := CellSpec{
<<<<<<< HEAD
		ID:         "test-cell-10",
		Boundaries: createTestBounds(),
		Capacity:   CellCapacity{MaxPlayers: 10},
=======
		ID: "test-cell-10",
		Boundaries: v1.WorldBounds{
			XMin: 0, XMax: 1000,
<<<<<<< HEAD
			YMin: &yMinVal, YMax: &yMaxVal,
=======
			YMin: &yMin, YMax: &yMax,
>>>>>>> main
		},
		Capacity: CellCapacity{MaxPlayers: 10},
>>>>>>> origin/main
	}

	cell, err := NewCell(spec)
	if err != nil {
		t.Fatalf("Failed to create cell: %v", err)
	}

	ctx := context.Background()
	err = cell.Start(ctx)
	if err != nil {
		t.Fatalf("Failed to start cell: %v", err)
	}

	// Wait for cell to become ready
	time.Sleep(time.Millisecond * 150)

	metrics := cell.GetMetrics()

	expectedMetrics := []string{
		"player_count", "max_players", "cpu_usage", "memory_usage",
		"tick_rate", "tick_duration_ms", "messages_per_second",
		"bytes_per_second", "state_size_bytes", "uptime_seconds",
	}

	for _, metric := range expectedMetrics {
		if _, exists := metrics[metric]; !exists {
			t.Errorf("Expected metric %s not found", metric)
		}
	}

	cell.Stop()
}

func TestCell_CheckpointRestore(t *testing.T) {
	yMin := float64(0)
	yMax := float64(1000)
	spec := CellSpec{
<<<<<<< HEAD
		ID:         "test-cell-11",
		Boundaries: createTestBounds(),
		Capacity:   CellCapacity{MaxPlayers: 10},
=======
		ID: "test-cell-11",
		Boundaries: v1.WorldBounds{
			XMin: 0, XMax: 1000,
<<<<<<< HEAD
			YMin: &yMinVal, YMax: &yMaxVal,
=======
			YMin: &yMin, YMax: &yMax,
>>>>>>> main
		},
		Capacity: CellCapacity{MaxPlayers: 10},
>>>>>>> origin/main
	}

	cell, err := NewCell(spec)
	if err != nil {
		t.Fatalf("Failed to create cell: %v", err)
	}

	ctx := context.Background()
	err = cell.Start(ctx)
	if err != nil {
		t.Fatalf("Failed to start cell: %v", err)
	}

	// Wait for cell to become ready
	time.Sleep(time.Millisecond * 150)

	// Add a player
	player := &PlayerState{
		ID:        "player-1",
		Position:  WorldPosition{X: 500, Y: 500},
		Connected: true,
	}

	err = cell.AddPlayer(player)
	if err != nil {
		t.Fatalf("Failed to add player: %v", err)
	}

	// Create checkpoint
	checkpoint, err := cell.Checkpoint()
	if err != nil {
		t.Fatalf("Failed to create checkpoint: %v", err)
	}

	// Remove player
	err = cell.RemovePlayer(player.ID)
	if err != nil {
		t.Fatalf("Failed to remove player: %v", err)
	}

	// Verify player is gone
	state := cell.GetState()
	if state.PlayerCount != 0 {
		t.Errorf("Expected player count 0 after removal, got %d", state.PlayerCount)
	}

	// Restore from checkpoint
	err = cell.Restore(checkpoint)
	if err != nil {
		t.Fatalf("Failed to restore from checkpoint: %v", err)
	}

	// Verify player is back
	state = cell.GetState()
	if state.PlayerCount != 1 {
		t.Errorf("Expected player count 1 after restore, got %d", state.PlayerCount)
	}

	if _, exists := state.Players[player.ID]; !exists {
		t.Error("Player not found after restore")
	}

	cell.Stop()
}
